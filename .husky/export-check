
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# Check for missing exports and other import-related issues
echo "üîç Checking exports and imports..."
npx eslint --config ./eslint/export-validation.js $(git diff --cached --name-only --diff-filter=ACMR | grep -E '\.(ts|tsx)$')

if [ $? -ne 0 ]; then
  echo "‚ùå Export validation failed. Please fix the issues and try again."
  echo "   Common issues:"
  echo "   - Importing a name that is not exported from a module"
  echo "   - Re-exporting the same name from multiple sources"
  echo "   - Missing export declarations"
  echo "   - Circular dependencies between modules"
  exit 1
fi

echo "‚úÖ Export validation passed."

# Additional checks for module naming consistency and ambiguity
echo "üîç Checking for ambiguous exports..."
ambiguous_exports=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -l "export \* from" | xargs grep -l "export {" || true)

if [ -n "$ambiguous_exports" ]; then
  echo "‚ö†Ô∏è  Warning: Potentially ambiguous exports found in:"
  echo "$ambiguous_exports"
  echo "   Consider using explicit exports to avoid naming conflicts."
  # This is just a warning, not an error that stops the commit
fi

# Check for duplicate exports across the codebase
echo "üîç Checking for duplicate export names..."
duplicate_check=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -h "export const" | grep -v "from" | awk '{print $3}' | sort | uniq -d)

if [ -n "$duplicate_check" ]; then
  echo "‚ö†Ô∏è  Warning: Potential duplicate export names found:"
  echo "$duplicate_check"
  echo "   Consider using unique names or explicit imports to avoid confusion."
  # This is just a warning, not an error that stops the commit
fi

# Enhanced check for re-exports with the same name
echo "üîç Checking for re-export conflicts..."
for file in $(find src -type f -name "index.ts"); do
  export_names=$(grep -E "export \* from|export {|export const" $file | sort)
  duplicate_exports=$(echo "$export_names" | grep -o -E "[a-zA-Z0-9_]+" | sort | uniq -d)
  
  if [ -n "$duplicate_exports" ]; then
    echo "‚ö†Ô∏è  Warning: Potential export name conflicts in $file:"
    echo "$duplicate_exports"
    echo "   Consider using explicit named exports to avoid ambiguity."
  fi
done

# More robust check for wildcard exports combined with direct exports
echo "üîç Running critical ambiguity check..."

# Check for files that have both direct exports and wildcard exports
for file in $(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -l "export \* from" | xargs grep -l "export const"); do
  echo "‚ö†Ô∏è File with both wildcard and direct exports detected: $file"
  echo "   This pattern can lead to ambiguous exports. Consider using explicit exports only."
  echo "   Example: 'export { specificFunction } from './module'' instead of 'export * from './module''"
done

# Check specifically for exported names from imported modules
echo "üîç Checking for ambiguous re-exports..."
for file in $(find src -type f -name "index.ts"); do
  import_patterns=$(grep -E "export \* from" $file | grep -o -E "'[^']+'" | tr -d "'" | sort)
  
  if [ -n "$import_patterns" ]; then
    echo "Checking re-exports in $file:"
    
    # For each wildcard export, check if any other export could conflict
    for import_path in $import_patterns; do
      target_file=$(find src -path "*${import_path}.ts")
      
      if [ -n "$target_file" ]; then
        exports_in_target=$(grep -E "export (const|function|class|interface|type|enum)" $target_file | awk '{print $3}' | cut -d '(' -f1 | cut -d ':' -f1 | sort)
        
        if [ -n "$exports_in_target" ]; then
          echo "‚ö†Ô∏è  $file re-exports these from $import_path:"
          echo "$exports_in_target"
          
          # Check each export against direct exports in the barrel file
          for export_name in $exports_in_target; do
            if grep -q "export const $export_name" "$file" || grep -q "export function $export_name" "$file" || grep -q "export class $export_name" "$file"; then
              echo "‚õî ERROR: Ambiguous export detected! '$export_name' is both directly exported and re-exported via wildcard!"
              exit 1
            fi
          done
        fi
      fi
    done
  fi
done

# Enhanced check for ambiguous exports in barrel files
echo "üîç Running enhanced checks for ambiguous exports in barrel files..."

for barrel_file in $(find src -name "index.ts"); do
  # Get directory of barrel file
  barrel_dir=$(dirname "$barrel_file")
  
  # Find all direct exports from other files
  direct_exports=$(grep -E "export \* from" "$barrel_file" | sed -E "s/.*from '(.*)'.*/\1/")
  
  # Check each direct export for conflicts
  for export_path in $direct_exports; do
    # Find the actual file being exported
    target_file="$barrel_dir/${export_path}.ts"
    
    if [ -f "$target_file" ]; then
      # Get exports from the target file
      target_exports=$(grep -E "export (const|function|class|enum|type|interface)" "$target_file" | sed -E "s/export (const|function|class|enum|type|interface) ([a-zA-Z0-9_]+).*/\2/")
      
      # For each export in the target file
      for export_name in $target_exports; do
        # Check if the same name is directly exported in the barrel file
        if grep -q "export const $export_name" "$barrel_file" || grep -q "export function $export_name" "$barrel_file" || grep -q "export class $export_name" "$barrel_file"; then
          echo "‚õî CRITICAL: Ambiguous export detected in $barrel_file"
          echo "   '$export_name' is exported both directly and via wildcard import from $export_path"
          echo "   This will cause TypeScript errors! Please fix this before committing."
          exit 1
        fi
      done
    fi
  done
done

echo "‚úÖ No ambiguous exports detected in barrel files."

# NEW: Check for proper function exports (must have return types)
echo "üîç Checking for function exports without explicit return types..."
function_exports_without_types=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -l "export function" | xargs grep -L "):.*{" || true)

if [ -n "$function_exports_without_types" ]; then
  echo "‚ö†Ô∏è Warning: Function exports without explicit return types found in:"
  echo "$function_exports_without_types"
  echo "   Consider adding explicit return types to all exported functions."
fi

# NEW: Check for large files that might need refactoring
echo "üîç Checking for large files that might need refactoring..."
large_files=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs wc -l | sort -nr | head -10)

echo "Largest files in the codebase:"
echo "$large_files"
echo "   Consider refactoring files over 300 lines into smaller, focused modules."

# NEW: Check for excessive barrel files (index.ts)
echo "üîç Checking for barrel files with too many exports..."
barrel_files=$(find src -name "index.ts" | xargs wc -l | sort -nr | head -5)

echo "Largest barrel files:"
echo "$barrel_files"
echo "   Consider splitting large barrel files into more focused modules."

# NEW: Check for files with too many imports
echo "üîç Checking for files with too many dependencies..."
files_with_many_imports=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -l "^import" | xargs grep -c "^import" | sort -nr | head -10)

echo "Files with most imports:"
echo "$files_with_many_imports"
echo "   Files with more than 15 imports might be doing too much. Consider splitting them."

# NEW: Check component file sizes
echo "üîç Checking component sizes..."
large_components=$(find src -type f -name "*.tsx" | xargs wc -l | sort -nr | head -10)

echo "Largest components:"
echo "$large_components"
echo "   Components over 200 lines should be split into smaller components."

# NEW: Check for direct DOM manipulation
echo "üîç Checking for direct DOM manipulation (which should use refs)..."
dom_manipulation=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -l "document\.get" || true)

if [ -n "$dom_manipulation" ]; then
  echo "‚ö†Ô∏è Warning: Direct DOM manipulation found in:"
  echo "$dom_manipulation"
  echo "   Use React refs instead of directly manipulating the DOM."
fi

# NEW: Check for inline JSX styles (should use Tailwind or CSS)
echo "üîç Checking for inline styles..."
inline_styles=$(find src -type f -name "*.tsx" | xargs grep -l "style=" || true)

if [ -n "$inline_styles" ]; then
  echo "‚ö†Ô∏è Warning: Inline styles found in:"
  echo "$inline_styles"
  echo "   Consider using Tailwind classes instead of inline styles."
fi

# NEW: Check for accessibility issues in JSX
echo "üîç Checking for basic accessibility issues..."
missing_alt=$(find src -type f -name "*.tsx" | xargs grep -l "<img" | xargs grep -L "alt=" || true)

if [ -n "$missing_alt" ]; then
  echo "‚ö†Ô∏è Warning: Images without alt attributes found in:"
  echo "$missing_alt"
  echo "   Always add alt attributes to images for accessibility."
fi

# NEW: Check for files that might have circular dependencies
echo "üîç Checking for potential circular dependencies..."
circular_imports=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -l "from '\.\." | sort)

echo "Files with parent imports (potential circular dependencies):"
echo "$circular_imports"
echo "   Review these files to ensure they don't create circular dependencies."

# NEW: Check for consistent naming conventions
echo "üîç Checking for consistent naming conventions..."
# Component files should use PascalCase
component_naming_issues=$(find src/components -type f -name "*.tsx" | grep -v -E '^[A-Z][a-zA-Z0-9]*\.tsx$' || true)
if [ -n "$component_naming_issues" ]; then
  echo "‚ö†Ô∏è Warning: Component files not following PascalCase naming convention:"
  echo "$component_naming_issues"
  echo "   Component files should use PascalCase (e.g., Button.tsx)."
fi

# Hook files should start with 'use'
hook_naming_issues=$(find src/hooks -type f -name "*.ts" | grep -v -E '^use[A-Z][a-zA-Z0-9]*\.ts$' || true)
if [ -n "$hook_naming_issues" ]; then
  echo "‚ö†Ô∏è Warning: Hook files not following 'use' prefix convention:"
  echo "$hook_naming_issues"
  echo "   Hook files should start with 'use' and use camelCase (e.g., useAuth.ts)."
fi

# NEW: Check for TypeScript 'any' type usage
echo "üîç Checking for 'any' type usage..."
any_usage=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -l ": any" || true)
if [ -n "$any_usage" ]; then
  echo "‚ö†Ô∏è Warning: 'any' type usage found in:"
  echo "$any_usage"
  echo "   Consider using more specific types for better type safety."
  echo "   If 'any' is necessary, use '// @ts-expect-error' or '// @ts-ignore' with explanation."
fi

# NEW: Check for console.log statements
echo "üîç Checking for console.log statements..."
console_logs=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -l "console\.log" || true)
if [ -n "$console_logs" ]; then
  echo "‚ö†Ô∏è Warning: console.log statements found in:"
  echo "$console_logs"
  echo "   Consider removing or replacing with proper logging mechanism before committing."
fi

# NEW: Check for TODO/FIXME comments without ticket numbers
echo "üîç Checking for TODO/FIXME comments without ticket numbers..."
todo_without_ticket=$(find src -type f -name "*.ts" -o -name "*.tsx" | xargs grep -E "// (TODO|FIXME)(?!: \[([A-Z]+-[0-9]+)\])" || true)
if [ -n "$todo_without_ticket" ]; then
  echo "‚ö†Ô∏è Warning: TODO/FIXME comments without ticket references:"
  echo "$todo_without_ticket"
  echo "   Format should be: // TODO: [TICKET-123] Description"
fi

echo "‚úÖ All export checks completed."
